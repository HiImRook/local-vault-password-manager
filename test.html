<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Valid Vault - Test</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 20px; }
    .container { max-width: 500px; margin: 0 auto; }
    h1 { color: #00d4aa; margin-bottom: 20px; text-align: center; }
    h2 { color: #888; font-size: 14px; margin: 20px 0 10px; text-transform: uppercase; }
    .section { background: #1a1a1a; border-radius: 8px; padding: 16px; margin-bottom: 12px; }
    button { background: #00d4aa; color: #000; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; margin: 4px; }
    button:hover { background: #00b894; }
    button.secondary { background: #333; color: #e0e0e0; }
    button.danger { background: #e74c3c; color: #fff; }
    button.small { padding: 8px 12px; font-size: 12px; }
    input { background: #2a2a2a; border: 1px solid #444; color: #e0e0e0; padding: 10px; border-radius: 6px; width: 100%; margin: 4px 0; }
    .log { background: #111; border-radius: 6px; padding: 12px; margin-top: 20px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; }
    .log-entry { padding: 4px 0; border-bottom: 1px solid #222; }
    .log-entry.success { color: #00d4aa; }
    .log-entry.error { color: #e74c3c; }
    .status { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin: 2px; }
    .status.active { background: #00d4aa; color: #000; }
    .status.inactive { background: #333; color: #888; }
    .hidden { display: none; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    .row input { flex: 1; margin: 0; }
    .eyeball { background: none; border: none; color: #888; cursor: pointer; padding: 8px; font-size: 16px; }
    .eyeball:hover { color: #00d4aa; }
    .eyeball svg { width: 20px; height: 20px; fill: currentColor; }
    .credential-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #333; }
    .credential-row:last-child { border-bottom: none; }
    .credential-info { flex: 1; }
    .credential-login { color: #00d4aa; font-weight: 500; }
    .credential-pass { color: #666; font-family: monospace; }
    .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 100; }
    .modal-content { background: #1a1a1a; border-radius: 12px; padding: 24px; max-width: 420px; width: 90%; max-height: 90vh; overflow-y: auto; }
    .modal h3 { color: #00d4aa; margin-bottom: 16px; }
    .timer { color: #e74c3c; font-size: 12px; margin-top: 8px; }
    .lockout-msg { color: #e74c3c; font-size: 12px; margin-top: 8px; padding: 8px; background: #2a1a1a; border-radius: 4px; }
    .pin-display { font-size: 48px; font-weight: bold; letter-spacing: 12px; text-align: center; color: #00d4aa; padding: 20px; background: #111; border-radius: 8px; margin: 16px 0; font-family: monospace; }
    .qr-container { background: #fff; padding: 16px; margin: 16px auto; display: inline-block; border-radius: 8px; }
    .qr-container svg { display: block; }
    .qr-wrapper { text-align: center; }
    .sync-step { color: #888; font-size: 14px; margin-bottom: 12px; }
    .sync-step.active { color: #00d4aa; }
    textarea { background: #2a2a2a; border: 1px solid #444; color: #e0e0e0; padding: 10px; border-radius: 6px; width: 100%; margin: 4px 0; font-family: monospace; font-size: 11px; resize: vertical; }
    .vault-info { background: #111; border-radius: 6px; padding: 12px; margin: 12px 0; font-size: 13px; }
    .vault-info-row { display: flex; justify-content: space-between; padding: 4px 0; }
    .vault-info-label { color: #888; }
    .vault-info-value { color: #00d4aa; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Valid Vault</h1>

    <div class="section">
      <div id="status">
        <span class="status inactive" id="status-fingerprint">Fingerprint</span>
        <span class="status inactive" id="status-pin">PIN</span>
        <span class="status inactive" id="status-password">Password</span>
        <span class="status inactive" id="status-session">Session</span>
      </div>
    </div>

    <h2>Auth</h2>
    <div class="section">
      <button onclick="authFingerprint()">Auth with Fingerprint</button>
      <button onclick="showEnrollFingerprint()" class="secondary small">Enroll New</button>
      <div class="row">
        <input type="text" id="pin-input" placeholder="PIN (4-6 digits)" maxlength="6">
        <button onclick="authPIN()">Auth</button>
        <button onclick="showSetPIN()" class="secondary small">Set</button>
      </div>
      <div class="row">
        <input type="password" id="password-input" placeholder="Password (8+ chars)">
        <button onclick="authPassword()">Auth</button>
        <button onclick="showSetPassword()" class="secondary small">Set</button>
      </div>
      <div id="lockout-display"></div>
    </div>

    <h2>Password Manager</h2>
    <div class="section">
      <div class="row">
        <input type="text" id="domain-input" placeholder="website.com">
        <button onclick="showSaveCredential()">Add</button>
        <button onclick="loadCredentials()" class="secondary">Load</button>
      </div>
      <div id="credentials-list"></div>
    </div>

    <h2>Secure Sync</h2>
    <div class="section">
      <button onclick="startSecureSync()">Secure Sync</button>
      <p style="color:#666;font-size:12px;margin-top:8px;">Sync your vault to another device</p>
    </div>

    <h2>Session</h2>
    <div class="section">
      <button onclick="lockAll()" class="danger">Lock All</button>
      <button onclick="clearAll()" class="danger">Clear All Data</button>
    </div>

    <div class="log" id="log"></div>
  </div>

  <div id="modal-container" class="hidden"></div>

  <script>

// Valid Vault - Bundled Build
// Generated: 2025-11-28T03:00:45.314Z
// This file is auto-generated. Do not edit directly.
// Edit the source modules and run: node build.js

// === crypto.js ===
const cryptoModule = (function() {
const SALT_LENGTH = 16
const IV_LENGTH = 12
const KEY_LENGTH = 256
const HASH_ITERATIONS = 3
const MASTER_KEY_LENGTH = 32

async function generateSalt() {
  return crypto.getRandomValues(new Uint8Array(SALT_LENGTH))
}

async function generateIV() {
  return crypto.getRandomValues(new Uint8Array(IV_LENGTH))
}

async function generateMasterKey() {
  return crypto.getRandomValues(new Uint8Array(MASTER_KEY_LENGTH))
}

async function deriveKeyFromSecret(secret, salt) {
  const encoder = new TextEncoder()
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    typeof secret === 'string' ? encoder.encode(secret) : secret,
    'PBKDF2',
    false,
    ['deriveKey']
  )
  
  return crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: KEY_LENGTH },
    false,
    ['wrapKey', 'unwrapKey', 'encrypt', 'decrypt']
  )
}

async function masterKeyToCryptoKey(masterKeyBytes) {
  return crypto.subtle.importKey(
    'raw',
    masterKeyBytes,
    { name: 'AES-GCM', length: KEY_LENGTH },
    true,
    ['encrypt', 'decrypt']
  )
}

async function wrapMasterKey(masterKeyBytes, wrappingKey) {
  const iv = await generateIV()
  const masterKey = await crypto.subtle.importKey(
    'raw',
    masterKeyBytes,
    { name: 'AES-GCM', length: KEY_LENGTH },
    true,
    ['encrypt', 'decrypt']
  )
  
  const wrapped = await crypto.subtle.wrapKey(
    'raw',
    masterKey,
    wrappingKey,
    { name: 'AES-GCM', iv: iv }
  )
  
  return {
    iv: Array.from(iv),
    wrapped: Array.from(new Uint8Array(wrapped))
  }
}

async function unwrapMasterKey(wrappedData, unwrappingKey) {
  const iv = new Uint8Array(wrappedData.iv)
  const wrapped = new Uint8Array(wrappedData.wrapped)
  
  const masterKey = await crypto.subtle.unwrapKey(
    'raw',
    wrapped,
    unwrappingKey,
    { name: 'AES-GCM', iv: iv },
    { name: 'AES-GCM', length: KEY_LENGTH },
    true,
    ['encrypt', 'decrypt']
  )
  
  return masterKey
}

async function encrypt(plaintext, key) {
  const encoder = new TextEncoder()
  const iv = await generateIV()
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    encoder.encode(plaintext)
  )
  
  return {
    iv: Array.from(iv),
    ciphertext: Array.from(new Uint8Array(ciphertext))
  }
}

async function decrypt(encrypted, key) {
  const decoder = new TextDecoder()
  const iv = new Uint8Array(encrypted.iv)
  const ciphertext = new Uint8Array(encrypted.ciphertext)
  
  const plaintext = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    ciphertext
  )
  
  return decoder.decode(plaintext)
}

async function argon2Hash(input, salt) {
  const encoder = new TextEncoder()
  const inputBytes = encoder.encode(input)
  const saltBytes = salt instanceof Uint8Array ? salt : new Uint8Array(salt)
  
  let result = new Uint8Array(await crypto.subtle.digest('SHA-256', 
    new Uint8Array([...inputBytes, ...saltBytes])
  ))
  
  for (let i = 0; i < HASH_ITERATIONS; i++) {
    const round = new Uint8Array([...result, ...saltBytes, i])
    result = new Uint8Array(await crypto.subtle.digest('SHA-256', round))
  }
  
  return Array.from(result)
}

async function hashPin(pin, salt) {
  return argon2Hash(pin, salt)
}

async function hashPassword(password, salt) {
  return argon2Hash(password, salt)
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false
  }
  return true
}

async function createBackupSignature(payload, key) {
  const encoder = new TextEncoder()
  const keyBytes = await crypto.subtle.exportKey('raw', key)
  
  const hmacKey = await crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  
  const signature = await crypto.subtle.sign('HMAC', hmacKey, encoder.encode(payload))
  return Array.from(new Uint8Array(signature))
}

async function verifyBackupSignature(payload, signature, key) {
  const encoder = new TextEncoder()
  const keyBytes = await crypto.subtle.exportKey('raw', key)
  
  const hmacKey = await crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['verify']
  )
  
  return crypto.subtle.verify('HMAC', hmacKey, new Uint8Array(signature), encoder.encode(payload))
}
return {
  generateSalt,
  generateIV,
  generateMasterKey,
  deriveKeyFromSecret,
  masterKeyToCryptoKey,
  wrapMasterKey,
  unwrapMasterKey,
  encrypt,
  decrypt,
  hashPin,
  hashPassword,
  arraysEqual,
  createBackupSignature,
  verifyBackupSignature
}
})();

// === store.js ===
const storeModule = (function() {
const DB_NAME = 'ValidVault'
const DB_VERSION = 1

let db = null

async function openDB() {
  if (db) return db
  
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)
    
    request.onerror = () => reject(request.error)
    
    request.onsuccess = () => {
      db = request.result
      resolve(db)
    }
    
    request.onupgradeneeded = (event) => {
      const database = event.target.result
      
      if (!database.objectStoreNames.contains('auth')) {
        database.createObjectStore('auth', { keyPath: 'id' })
      }
      
      if (!database.objectStoreNames.contains('passwords')) {
        database.createObjectStore('passwords', { keyPath: 'id' })
      }
      
      if (!database.objectStoreNames.contains('wallets')) {
        database.createObjectStore('wallets', { keyPath: 'id' })
      }
    }
  })
}

async function getStore(storeName, mode) {
  const database = await openDB()
  const tx = database.transaction(storeName, mode)
  return tx.objectStore(storeName)
}

async function get(storeName, key) {
  const store = await getStore(storeName, 'readonly')
  return new Promise((resolve, reject) => {
    const request = store.get(key)
    request.onerror = () => reject(request.error)
    request.onsuccess = () => resolve(request.result || null)
  })
}

async function put(storeName, data) {
  const store = await getStore(storeName, 'readwrite')
  return new Promise((resolve, reject) => {
    const request = store.put(data)
    request.onerror = () => reject(request.error)
    request.onsuccess = () => resolve(request.result)
  })
}

async function remove(storeName, key) {
  const store = await getStore(storeName, 'readwrite')
  return new Promise((resolve, reject) => {
    const request = store.delete(key)
    request.onerror = () => reject(request.error)
    request.onsuccess = () => resolve()
  })
}

async function getAuth() {
  return get('auth', 'primary')
}

async function setAuth(authData) {
  return put('auth', { id: 'primary', ...authData })
}

async function getPasswordVault() {
  return get('passwords', 'vault')
}

async function setPasswordVault(vaultData) {
  return put('passwords', { id: 'vault', ...vaultData })
}

async function getWalletVault() {
  return get('wallets', 'vault')
}

async function setWalletVault(vaultData) {
  return put('wallets', { id: 'vault', ...vaultData })
}

async function clearAll() {
  const database = await openDB()
  const stores = ['auth', 'passwords', 'wallets']
  
  for (const storeName of stores) {
    const tx = database.transaction(storeName, 'readwrite')
    const store = tx.objectStore(storeName)
    store.clear()
  }
}
return {
  openDB,
  get,
  put,
  remove,
  getAuth,
  setAuth,
  getPasswordVault,
  setPasswordVault,
  getWalletVault,
  setWalletVault,
  clearAll
}
})();

// === session.js ===
const sessionModule = (function() {
const session = {
  masterKey: null,
  unlockedDomains: new Set(),
  lastActivity: 0,
  timeoutId: null
}

const SESSION_TIMEOUT = 300000

function setMasterKey(key) {
  session.masterKey = key
  session.lastActivity = Date.now()
  startTimeout()
}

function getMasterKey() {
  return session.masterKey
}

function hasMasterKey() {
  return session.masterKey !== null
}

function unlockDomain(domain) {
  session.unlockedDomains.add(domain)
}

function lockDomain(domain) {
  session.unlockedDomains.delete(domain)
}

function isDomainUnlocked(domain) {
  return session.unlockedDomains.has(domain)
}

function getUnlockedDomains() {
  return Array.from(session.unlockedDomains)
}

function resetActivity() {
  session.lastActivity = Date.now()
}

function checkTimeout() {
  if (!session.masterKey) return false
  
  const elapsed = Date.now() - session.lastActivity
  if (elapsed >= SESSION_TIMEOUT) {
    lockAll()
    return true
  }
  
  return false
}

function startTimeout() {
  stopTimeout()
  session.timeoutId = setInterval(() => {
    if (checkTimeout()) {
      console.log('Session locked due to inactivity')
    }
  }, 10000)
}

function stopTimeout() {
  if (session.timeoutId) {
    clearInterval(session.timeoutId)
    session.timeoutId = null
  }
}

function lockAll() {
  session.masterKey = null
  session.unlockedDomains.clear()
  session.lastActivity = 0
  stopTimeout()
}

function getState() {
  return {
    hasMasterKey: hasMasterKey(),
    unlockedDomains: getUnlockedDomains(),
    lastActivity: session.lastActivity
  }
}
return {
  setMasterKey,
  getMasterKey,
  hasMasterKey,
  unlockDomain,
  lockDomain,
  isDomainUnlocked,
  getUnlockedDomains,
  resetActivity,
  checkTimeout,
  lockAll,
  getState
}
})();

// === passwords.js ===
const passwordsModule = (function() {
const { encrypt, decrypt } = cryptoModule
const { getPasswordVault, setPasswordVault } = storeModule
function generateId() {
  return crypto.randomUUID()
}

async function ensureVault() {
  const existing = await getPasswordVault()
  if (existing) return { success: true }
  
  const vault = {
    meta: {
      version: 1,
      createdAt: Date.now(),
      lastAccess: Date.now()
    },
    credentials: {}
  }
  
  await setPasswordVault(vault)
  return { success: true }
}

async function saveCredential(domain, username, password, masterKey) {
  await ensureVault()
  const vault = await getPasswordVault()
  
  const id = generateId()
  const encUsername = await encrypt(username, masterKey)
  const encPassword = await encrypt(password, masterKey)
  
  const credential = {
    id,
    username: encUsername,
    password: encPassword,
    createdAt: Date.now(),
    updatedAt: Date.now()
  }
  
  if (!vault.credentials[domain]) {
    vault.credentials[domain] = []
  }
  
  vault.credentials[domain].push(credential)
  vault.meta.lastAccess = Date.now()
  
  await setPasswordVault(vault)
  return { success: true, id }
}

async function getCredentials(domain, masterKey) {
  await ensureVault()
  const vault = await getPasswordVault()
  
  const domainCreds = vault.credentials[domain]
  if (!domainCreds || domainCreds.length === 0) {
    return { success: true, credentials: [] }
  }
  
  const decrypted = []
  for (const cred of domainCreds) {
    try {
      decrypted.push({
        id: cred.id,
        username: await decrypt(cred.username, masterKey),
        password: await decrypt(cred.password, masterKey),
        createdAt: cred.createdAt,
        updatedAt: cred.updatedAt
      })
    } catch (error) {
      return { success: false, error: 'Decryption failed' }
    }
  }
  
  return { success: true, credentials: decrypted }
}

async function getAllDomains() {
  await ensureVault()
  const vault = await getPasswordVault()
  
  return { success: true, domains: Object.keys(vault.credentials) }
}

async function updateCredential(credentialId, updates, masterKey) {
  const vault = await getPasswordVault()
  if (!vault) return { success: false, error: 'No vault' }
  
  for (const domain of Object.keys(vault.credentials)) {
    const creds = vault.credentials[domain]
    const index = creds.findIndex(c => c.id === credentialId)
    
    if (index !== -1) {
      if (updates.username) {
        creds[index].username = await encrypt(updates.username, masterKey)
      }
      if (updates.password) {
        creds[index].password = await encrypt(updates.password, masterKey)
      }
      creds[index].updatedAt = Date.now()
      vault.meta.lastAccess = Date.now()
      
      await setPasswordVault(vault)
      return { success: true }
    }
  }
  
  return { success: false, error: 'Credential not found' }
}

async function deleteCredential(credentialId) {
  const vault = await getPasswordVault()
  if (!vault) return { success: false, error: 'No vault' }
  
  for (const domain of Object.keys(vault.credentials)) {
    const creds = vault.credentials[domain]
    const index = creds.findIndex(c => c.id === credentialId)
    
    if (index !== -1) {
      creds.splice(index, 1)
      
      if (creds.length === 0) {
        delete vault.credentials[domain]
      }
      
      vault.meta.lastAccess = Date.now()
      await setPasswordVault(vault)
      return { success: true }
    }
  }
  
  return { success: false, error: 'Credential not found' }
}

async function autofill(domain, credentialId, masterKey) {
  const result = await getCredentials(domain, masterKey)
  if (!result.success) return result
  
  if (result.credentials.length === 0) {
    return { success: false, error: 'No credentials for domain' }
  }
  
  if (credentialId) {
    const cred = result.credentials.find(c => c.id === credentialId)
    if (cred) return { success: true, username: cred.username, password: cred.password }
    return { success: false, error: 'Credential not found' }
  }
  
  const cred = result.credentials[0]
  return { success: true, username: cred.username, password: cred.password }
}
return {
  ensureVault,
  saveCredential,
  getCredentials,
  getAllDomains,
  updateCredential,
  deleteCredential,
  autofill
}
})();

// === auth.js ===
const authModule = (function() {
const {
  generateSalt,
  generateMasterKey,
  deriveKeyFromSecret,
  masterKeyToCryptoKey,
  wrapMasterKey,
  unwrapMasterKey,
  hashPin,
  hashPassword,
  arraysEqual
} = cryptoModule
const { getAuth, setAuth } = storeModule
generateSalt,
  generateMasterKey,
  deriveKeyFromSecret,
  masterKeyToCryptoKey,
  wrapMasterKey,
  unwrapMasterKey,
  hashPin,
  hashPassword,
  arraysEqual
} from './crypto.js'


const RP_NAME = 'Valid Vault'
const RP_ID = location.hostname
const FINGERPRINT_SECRET = 'valid-vault-fingerprint-auth-v1'

const attempts = new Map()
const LOCKOUT_MS = 60000
const MAX_ATTEMPTS = 3
const CREATION_TIMEOUT_MS = 60000

const creationTimers = new Map()

function checkRateLimit(type) {
  const record = attempts.get(type)
  if (!record) return { allowed: true }
  if (Date.now() - record.lastAttempt > LOCKOUT_MS) {
    attempts.delete(type)
    return { allowed: true }
  }
  if (record.count >= MAX_ATTEMPTS) {
    const remaining = Math.ceil((LOCKOUT_MS - (Date.now() - record.lastAttempt)) / 1000)
    return { allowed: false, remaining }
  }
  return { allowed: true }
}

function recordFailedAttempt(type) {
  const record = attempts.get(type) || { count: 0, lastAttempt: 0 }
  record.count++
  record.lastAttempt = Date.now()
  attempts.set(type, record)
}

function clearAttempts(type) {
  attempts.delete(type)
}

function startCreationTimer(type) {
  cancelCreationTimer(type)
  const timer = {
    startedAt: Date.now(),
    timeoutId: setTimeout(() => {
      creationTimers.delete(type)
    }, CREATION_TIMEOUT_MS)
  }
  creationTimers.set(type, timer)
  return timer.startedAt
}

function checkCreationTimer(type) {
  const timer = creationTimers.get(type)
  if (!timer) return { valid: false, error: 'Creation session expired' }
  if (Date.now() - timer.startedAt > CREATION_TIMEOUT_MS) {
    creationTimers.delete(type)
    return { valid: false, error: 'Creation session expired' }
  }
  return { valid: true, remaining: Math.ceil((CREATION_TIMEOUT_MS - (Date.now() - timer.startedAt)) / 1000) }
}

function cancelCreationTimer(type) {
  const timer = creationTimers.get(type)
  if (timer) {
    clearTimeout(timer.timeoutId)
    creationTimers.delete(type)
  }
}

async function initAuth() {
  const auth = await getAuth()
  return {
    hasFingerprint: !!(auth && auth.fingerprintEnabled),
    hasPIN: !!(auth && auth.pinHash),
    hasPassword: !!(auth && auth.passwordHash),
    hasMasterKey: !!(auth && auth.masterKey),
    isNew: !auth
  }
}

function startFingerprintEnrollment() {
  return startCreationTimer('fingerprint')
}

async function enrollFingerprint(existingMasterKey) {
  const timerCheck = checkCreationTimer('fingerprint')
  if (!timerCheck.valid) {
    return { success: false, error: timerCheck.error }
  }

  try {
    const challenge = crypto.getRandomValues(new Uint8Array(32))
    const userId = new TextEncoder().encode('valid-vault-user')

    const credential = await navigator.credentials.create({
      publicKey: {
        challenge: challenge,
        rp: { name: RP_NAME, id: RP_ID },
        user: {
          id: userId,
          name: 'vault-user',
          displayName: 'Vault User'
        },
        pubKeyCredParams: [
          { alg: -7, type: 'public-key' },
          { alg: -257, type: 'public-key' }
        ],
        authenticatorSelection: {
          authenticatorAttachment: 'platform',
          userVerification: 'required',
          residentKey: 'preferred'
        },
        timeout: 60000
      }
    })

    const auth = await getAuth() || {}
    
    if (!auth.fingerprintSalt) {
      auth.fingerprintSalt = Array.from(await generateSalt())
    }

    const salt = new Uint8Array(auth.fingerprintSalt)
    const wrappingKey = await deriveKeyFromSecret(FINGERPRINT_SECRET, salt)

    let masterKeyBytes
    if (existingMasterKey) {
      masterKeyBytes = existingMasterKey instanceof CryptoKey
        ? new Uint8Array(await crypto.subtle.exportKey('raw', existingMasterKey))
        : new Uint8Array(existingMasterKey)
    } else if (auth.masterKey) {
      masterKeyBytes = new Uint8Array(auth.masterKey)
    } else {
      masterKeyBytes = await generateMasterKey()
      auth.masterKey = Array.from(masterKeyBytes)
    }

    const wrappedForFingerprint = await wrapMasterKey(masterKeyBytes, wrappingKey)
    auth.fingerprintWrappedKey = wrappedForFingerprint
    auth.fingerprintEnabled = true

    await setAuth(auth)

    const masterKey = await masterKeyToCryptoKey(masterKeyBytes)

    cancelCreationTimer('fingerprint')
    return { success: true, masterKey }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

async function authenticateFingerprint() {
  const rateCheck = checkRateLimit('fingerprint')
  if (!rateCheck.allowed) {
    return { success: false, error: `Too many attempts. Wait ${rateCheck.remaining}s` }
  }

  try {
    const auth = await getAuth()
    if (!auth || !auth.fingerprintEnabled) {
      return { success: false, error: 'No fingerprint enrolled' }
    }

    if (!auth.fingerprintWrappedKey) {
      return { success: false, error: 'Fingerprint not configured properly' }
    }

    const challenge = crypto.getRandomValues(new Uint8Array(32))

    await navigator.credentials.get({
      publicKey: {
        challenge: challenge,
        rpId: RP_ID,
        userVerification: 'required',
        timeout: 60000
      }
    })

    const salt = new Uint8Array(auth.fingerprintSalt)
    const unwrappingKey = await deriveKeyFromSecret(FINGERPRINT_SECRET, salt)

    const masterKey = await unwrapMasterKey(auth.fingerprintWrappedKey, unwrappingKey)

    clearAttempts('fingerprint')
    return { success: true, masterKey }
  } catch (error) {
    recordFailedAttempt('fingerprint')
    return { success: false, error: error.message }
  }
}

function startPINCreation() {
  return startCreationTimer('pin')
}

async function setPIN(pin, existingMasterKey) {
  const timerCheck = checkCreationTimer('pin')
  if (!timerCheck.valid) {
    return { success: false, error: timerCheck.error }
  }

  if (pin.length < 4 || pin.length > 6 || !/^\d+$/.test(pin)) {
    return { success: false, error: 'PIN must be 4-6 digits' }
  }

  const auth = await getAuth() || {}
  const salt = auth.pinSalt ? new Uint8Array(auth.pinSalt) : await generateSalt()
  const hash = await hashPin(pin, salt)

  auth.pinHash = hash
  auth.pinSalt = Array.from(salt)

  const wrappingKey = await deriveKeyFromSecret(pin, salt)

  let masterKeyBytes
  let isNewVault = false

  if (existingMasterKey) {
    masterKeyBytes = existingMasterKey instanceof CryptoKey
      ? new Uint8Array(await crypto.subtle.exportKey('raw', existingMasterKey))
      : new Uint8Array(existingMasterKey)
  } else if (auth.masterKey) {
    masterKeyBytes = new Uint8Array(auth.masterKey)
  } else {
    masterKeyBytes = await generateMasterKey()
    auth.masterKey = Array.from(masterKeyBytes)
    isNewVault = true
  }

  const wrappedForPIN = await wrapMasterKey(masterKeyBytes, wrappingKey)
  auth.pinWrappedKey = wrappedForPIN

  await setAuth(auth)

  cancelCreationTimer('pin')

  const masterKey = await masterKeyToCryptoKey(masterKeyBytes)
  return { success: true, masterKey, isNewVault }
}

function startPasswordCreation() {
  return startCreationTimer('password')
}

async function setPassword(password, existingMasterKey) {
  const timerCheck = checkCreationTimer('password')
  if (!timerCheck.valid) {
    return { success: false, error: timerCheck.error }
  }

  if (password.length < 8) {
    return { success: false, error: 'Password must be at least 8 characters' }
  }

  const auth = await getAuth() || {}
  const salt = auth.passwordSalt ? new Uint8Array(auth.passwordSalt) : await generateSalt()
  const hash = await hashPassword(password, salt)

  auth.passwordHash = hash
  auth.passwordSalt = Array.from(salt)

  const wrappingKey = await deriveKeyFromSecret(password, salt)

  let masterKeyBytes
  let isNewVault = false

  if (existingMasterKey) {
    masterKeyBytes = existingMasterKey instanceof CryptoKey
      ? new Uint8Array(await crypto.subtle.exportKey('raw', existingMasterKey))
      : new Uint8Array(existingMasterKey)
  } else if (auth.masterKey) {
    masterKeyBytes = new Uint8Array(auth.masterKey)
  } else {
    masterKeyBytes = await generateMasterKey()
    auth.masterKey = Array.from(masterKeyBytes)
    isNewVault = true
  }

  const wrappedForPassword = await wrapMasterKey(masterKeyBytes, wrappingKey)
  auth.passwordWrappedKey = wrappedForPassword

  await setAuth(auth)

  cancelCreationTimer('password')

  const masterKey = await masterKeyToCryptoKey(masterKeyBytes)
  return { success: true, masterKey, isNewVault }
}

async function authenticatePIN(pin) {
  const rateCheck = checkRateLimit('pin')
  if (!rateCheck.allowed) {
    return { success: false, error: `Too many attempts. Wait ${rateCheck.remaining}s` }
  }

  const auth = await getAuth()
  if (!auth || !auth.pinHash) {
    return { success: false, error: 'No PIN set' }
  }

  const salt = new Uint8Array(auth.pinSalt)
  const hash = await hashPin(pin, salt)

  if (!arraysEqual(hash, auth.pinHash)) {
    recordFailedAttempt('pin')
    return { success: false, error: 'Invalid PIN' }
  }

  try {
    const unwrappingKey = await deriveKeyFromSecret(pin, salt)
    const masterKey = await unwrapMasterKey(auth.pinWrappedKey, unwrappingKey)

    clearAttempts('pin')
    return { success: true, masterKey }
  } catch (error) {
    recordFailedAttempt('pin')
    return { success: false, error: 'Decryption failed' }
  }
}

async function authenticatePassword(password) {
  const rateCheck = checkRateLimit('password')
  if (!rateCheck.allowed) {
    return { success: false, error: `Too many attempts. Wait ${rateCheck.remaining}s` }
  }

  const auth = await getAuth()
  if (!auth || !auth.passwordHash) {
    return { success: false, error: 'No password set' }
  }

  const salt = new Uint8Array(auth.passwordSalt)
  const hash = await hashPassword(password, salt)

  if (!arraysEqual(hash, auth.passwordHash)) {
    recordFailedAttempt('password')
    return { success: false, error: 'Invalid password' }
  }

  try {
    const unwrappingKey = await deriveKeyFromSecret(password, salt)
    const masterKey = await unwrapMasterKey(auth.passwordWrappedKey, unwrappingKey)

    clearAttempts('password')
    return { success: true, masterKey }
  } catch (error) {
    recordFailedAttempt('password')
    return { success: false, error: 'Decryption failed' }
  }
}

async function removeFingerprint() {
  const auth = await getAuth()
  if (!auth) return { success: false, error: 'No auth configured' }

  if (!auth.pinHash && !auth.passwordHash) {
    return { success: false, error: 'Cannot remove fingerprint without PIN or password backup' }
  }

  delete auth.fingerprintEnabled
  delete auth.fingerprintWrappedKey
  await setAuth(auth)

  return { success: true }
}

async function removePIN() {
  const auth = await getAuth()
  if (!auth) return { success: false, error: 'No auth configured' }

  if (!auth.fingerprintEnabled && !auth.passwordHash) {
    return { success: false, error: 'Cannot remove PIN without fingerprint or password backup' }
  }

  delete auth.pinHash
  delete auth.pinSalt
  delete auth.pinWrappedKey
  await setAuth(auth)

  return { success: true }
}

async function removePassword() {
  const auth = await getAuth()
  if (!auth) return { success: false, error: 'No auth configured' }

  if (!auth.fingerprintEnabled && !auth.pinHash) {
    return { success: false, error: 'Cannot remove password without fingerprint or PIN backup' }
  }

  delete auth.passwordHash
  delete auth.passwordSalt
  delete auth.passwordWrappedKey
  await setAuth(auth)

  return { success: true }
}
return {
  initAuth,
  startFingerprintEnrollment,
  enrollFingerprint,
  authenticateFingerprint,
  startPINCreation,
  setPIN,
  startPasswordCreation,
  setPassword,
  authenticatePIN,
  authenticatePassword,
  removeFingerprint,
  removePIN,
  removePassword,
  checkRateLimit,
  checkCreationTimer
}
})();

// === pairing.js ===
const pairingModule = (function() {
const { getPasswordVault, setPasswordVault, getAuth, setAuth } = storeModule
const { createBackupSignature, verifyBackupSignature } = cryptoModule
const PAIRING_TIMEOUT = 60000

function generatePairingCode() {
  const code = Math.floor(1000 + Math.random() * 9000)
  return code.toString()
}

function generateSessionId() {
  return crypto.randomUUID()
}

async function generateKeyPair() {
  const keyPair = await crypto.subtle.generateKey(
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    ['deriveKey', 'deriveBits']
  )

  const publicKeyRaw = await crypto.subtle.exportKey('raw', keyPair.publicKey)

  return {
    privateKey: keyPair.privateKey,
    publicKey: Array.from(new Uint8Array(publicKeyRaw))
  }
}

async function deriveSharedKey(privateKey, publicKeyRaw) {
  const publicKey = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(publicKeyRaw),
    { name: 'ECDH', namedCurve: 'P-256' },
    false,
    []
  )

  return crypto.subtle.deriveKey(
    { name: 'ECDH', public: publicKey },
    privateKey,
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  )
}

async function derivePinFromSharedKey(sharedKey) {
  const keyBytes = await crypto.subtle.exportKey('raw', sharedKey)
  const view = new DataView(keyBytes)
  const num = view.getUint32(0, true)
  return String(num % 10000).padStart(4, '0')
}

async function initiatePairing() {
  const keyPair = await generateKeyPair()
  const sessionId = generateSessionId()

  const qrData = JSON.stringify({
    type: 'valid-vault-pair',
    sessionId,
    publicKey: keyPair.publicKey
  })

  return {
    qrData,
    sessionId,
    privateKey: keyPair.privateKey,
    expiresAt: Date.now() + PAIRING_TIMEOUT
  }
}

async function respondToPairing(sourcePublicKey) {
  const keyPair = await generateKeyPair()
  const sharedKey = await deriveSharedKey(keyPair.privateKey, sourcePublicKey)
  const pin = await derivePinFromSharedKey(sharedKey)

  const responseData = JSON.stringify({
    type: 'valid-vault-pair-response',
    publicKey: keyPair.publicKey
  })

  return {
    responseData,
    sharedKey,
    pin
  }
}

async function completePairing(privateKey, targetPublicKey) {
  const sharedKey = await deriveSharedKey(privateKey, targetPublicKey)
  const pin = await derivePinFromSharedKey(sharedKey)

  return {
    sharedKey,
    pin
  }
}

async function requestPairing() {
  const code = generatePairingCode()
  const sessionId = generateSessionId()
  const keyPair = await generateKeyPair()

  return {
    code,
    sessionId,
    privateKey: keyPair.privateKey,
    publicKey: keyPair.publicKey,
    expiresAt: Date.now() + PAIRING_TIMEOUT
  }
}

function parseQR(qrData) {
  try {
    const data = JSON.parse(qrData)
    if (data.type !== 'valid-vault-pair') {
      return { success: false, error: 'Invalid QR code' }
    }
    return { success: true, sessionId: data.sessionId, publicKey: data.publicKey }
  } catch (error) {
    return { success: false, error: 'Invalid QR format' }
  }
}

function parseResponse(responseData) {
  try {
    const data = JSON.parse(responseData)
    if (data.type !== 'valid-vault-pair-response') {
      return { success: false, error: 'Invalid response' }
    }
    return { success: true, publicKey: data.publicKey }
  } catch (error) {
    return { success: false, error: 'Invalid response format' }
  }
}

async function prepareTransfer(masterKey) {
  const vault = await getPasswordVault()
  const auth = await getAuth()

  if (!vault) {
    return { success: false, error: 'No vault to transfer' }
  }

  const passwordCount = Object.values(vault.credentials || {}).flat().length

  const payload = JSON.stringify({
    version: 1,
    createdAt: Date.now(),
    passwordCount,
    vault: vault,
    auth: {
      masterKey: auth.masterKey,
      fingerprintSalt: auth.fingerprintSalt || null,
      fingerprintEnabled: auth.fingerprintEnabled || false,
      fingerprintWrappedKey: auth.fingerprintWrappedKey || null,
      pinSalt: auth.pinSalt || null,
      pinHash: auth.pinHash || null,
      pinWrappedKey: auth.pinWrappedKey || null,
      passwordSalt: auth.passwordSalt || null,
      passwordHash: auth.passwordHash || null,
      passwordWrappedKey: auth.passwordWrappedKey || null
    }
  })

  const masterKeyForSig = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(auth.masterKey),
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  )

  const signature = await createBackupSignature(payload, masterKeyForSig)

  return {
    success: true,
    data: {
      payload,
      signature
    },
    meta: {
      passwordCount,
      createdAt: Date.now()
    }
  }
}

async function encryptTransfer(transferData, sharedKey) {
  const encoder = new TextEncoder()
  const iv = crypto.getRandomValues(new Uint8Array(12))

  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    sharedKey,
    encoder.encode(JSON.stringify(transferData))
  )

  return {
    iv: Array.from(iv),
    ciphertext: Array.from(new Uint8Array(ciphertext))
  }
}

async function decryptTransfer(encrypted, sharedKey) {
  const decoder = new TextDecoder()

  const plaintext = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: new Uint8Array(encrypted.iv) },
    sharedKey,
    new Uint8Array(encrypted.ciphertext)
  )

  return JSON.parse(decoder.decode(plaintext))
}

async function verifyTransfer(transferData, masterKeyBytes) {
  const masterKey = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(masterKeyBytes),
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  )

  const valid = await verifyBackupSignature(transferData.payload, transferData.signature, masterKey)

  if (!valid) {
    return { valid: false, error: 'Backup corrupted or tampered' }
  }

  const meta = JSON.parse(transferData.payload)
  return {
    valid: true,
    createdAt: meta.createdAt,
    passwordCount: meta.passwordCount
  }
}

async function receiveTransfer(transferData) {
  const data = JSON.parse(transferData.payload)

  const verification = await verifyTransfer(transferData, data.auth.masterKey)
  if (!verification.valid) {
    return { success: false, error: verification.error }
  }

  const vault = data.vault
  vault.meta.lastAccess = Date.now()
  await setPasswordVault(vault)

  await setAuth({
    masterKey: data.auth.masterKey,
    fingerprintSalt: data.auth.fingerprintSalt,
    fingerprintEnabled: data.auth.fingerprintEnabled,
    fingerprintWrappedKey: data.auth.fingerprintWrappedKey,
    pinSalt: data.auth.pinSalt,
    pinHash: data.auth.pinHash,
    pinWrappedKey: data.auth.pinWrappedKey,
    passwordSalt: data.auth.passwordSalt,
    passwordHash: data.auth.passwordHash,
    passwordWrappedKey: data.auth.passwordWrappedKey
  })

  const masterKey = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(data.auth.masterKey),
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  )

  return {
    success: true,
    masterKey,
    imported: {
      passwordCount: verification.passwordCount
    }
  }
}

function isExpired(expiresAt) {
  return Date.now() > expiresAt
}
return {
  generatePairingCode,
  generateSessionId,
  initiatePairing,
  respondToPairing,
  completePairing,
  requestPairing,
  parseQR,
  parseResponse,
  prepareTransfer,
  encryptTransfer,
  decryptTransfer,
  verifyTransfer,
  receiveTransfer,
  deriveSharedKey,
  derivePinFromSharedKey,
  isExpired
}
})();

// === Unified API ===
const vault = {
  crypto: cryptoModule,
  store: storeModule,
  session: sessionModule,
  passwords: passwordsModule,
  auth: authModule,
  pairing: pairingModule
}
const pairing = pairingModule

window.vault = vault
window.pairing = pairing

    let countdownInterval = null
    let syncState = {}

    function log(message, type = 'info') {
      const logEl = document.getElementById('log')
      const entry = document.createElement('div')
      entry.className = `log-entry ${type}`
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
      logEl.insertBefore(entry, logEl.firstChild)
    }

    function showModal(content) {
      const container = document.getElementById('modal-container')
      container.innerHTML = `<div class="modal" onclick="if(event.target===this)hideModal()"><div class="modal-content">${content}</div></div>`
      container.classList.remove('hidden')
    }

    window.hideModal = function() {
      document.getElementById('modal-container').classList.add('hidden')
      if (countdownInterval) {
        clearInterval(countdownInterval)
        countdownInterval = null
      }
      syncState = {}
    }

    function startCountdown(elementId, seconds, onExpire) {
      let remaining = seconds
      const el = document.getElementById(elementId)
      if (el) el.textContent = `${remaining}s remaining`

      countdownInterval = setInterval(() => {
        remaining--
        if (el) el.textContent = `${remaining}s remaining`
        if (remaining <= 0) {
          clearInterval(countdownInterval)
          countdownInterval = null
          if (onExpire) onExpire()
        }
      }, 1000)
    }

    function showLockout(type, remaining) {
      const display = document.getElementById('lockout-display')
      display.innerHTML = `<div class="lockout-msg">Too many ${type} attempts. Wait ${remaining}s</div>`

      const interval = setInterval(() => {
        remaining--
        if (remaining <= 0) {
          clearInterval(interval)
          display.innerHTML = ''
        } else {
          display.innerHTML = `<div class="lockout-msg">Too many ${type} attempts. Wait ${remaining}s</div>`
        }
      }, 1000)
    }

    function generateQRCode(data, size = 200) {
      const matrix = generateQRMatrix(data)
      const moduleCount = matrix.length
      const moduleSize = Math.floor(size / moduleCount)
      const actualSize = moduleSize * moduleCount

      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${actualSize}" height="${actualSize}" viewBox="0 0 ${moduleCount} ${moduleCount}">`
      svg += `<rect width="${moduleCount}" height="${moduleCount}" fill="white"/>`

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          if (matrix[row][col]) {
            svg += `<rect x="${col}" y="${row}" width="1" height="1" fill="black"/>`
          }
        }
      }

      svg += '</svg>'
      return svg
    }

    function generateQRMatrix(data) {
      const version = getMinVersion(data.length)
      const size = version * 4 + 17
      const matrix = Array(size).fill(null).map(() => Array(size).fill(null))
      const reserved = Array(size).fill(null).map(() => Array(size).fill(false))

      addFinderPatterns(matrix, reserved, size)
      addAlignmentPatterns(matrix, reserved, version)
      addTimingPatterns(matrix, reserved, size)
      matrix[version * 4 + 9][8] = true
      reserved[version * 4 + 9][8] = true
      reserveFormatArea(reserved, size)

      const dataCodewords = encodeData(data, version)
      const finalCodewords = addErrorCorrection(dataCodewords, version)
      placeDataBits(matrix, reserved, size, finalCodewords)

      const bestMask = findBestMask(matrix, reserved, size)
      applyMask(matrix, reserved, size, bestMask)
      addFormatInfo(matrix, size, bestMask)

      return matrix
    }

    function getMinVersion(len) {
      const caps = [17,32,53,78,106,134,154,192,230,271]
      for (let v = 1; v <= 10; v++) if (caps[v-1] >= len) return v
      return 10
    }

    function addFinderPatterns(matrix, reserved, size) {
      const positions = [[0,0], [size-7,0], [0,size-7]]
      for (const [row, col] of positions) {
        for (let r = -1; r <= 7; r++) {
          for (let c = -1; c <= 7; c++) {
            const rr = row + r, cc = col + c
            if (rr < 0 || rr >= size || cc < 0 || cc >= size) continue
            if (r >= 0 && r <= 6 && c >= 0 && c <= 6) {
              const isBlack = r === 0 || r === 6 || c === 0 || c === 6 || (r >= 2 && r <= 4 && c >= 2 && c <= 4)
              matrix[rr][cc] = isBlack
            } else {
              matrix[rr][cc] = false
            }
            reserved[rr][cc] = true
          }
        }
      }
    }

    function addAlignmentPatterns(matrix, reserved, version) {
      if (version < 2) return
      const positions = getAlignmentPositions(version)
      for (const row of positions) {
        for (const col of positions) {
          if (reserved[row]?.[col]) continue
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              const isBlack = r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)
              matrix[row + r][col + c] = isBlack
              reserved[row + r][col + c] = true
            }
          }
        }
      }
    }

    function getAlignmentPositions(version) {
      if (version === 1) return []
      const size = version * 4 + 17
      if (version <= 6) return [6, size - 7]
      const intervals = [0,0,18,22,26,30,34,22,24,26,28]
      const step = intervals[version] || 28
      const positions = [6]
      let pos = size - 7
      while (pos > 6 + step) { positions.unshift(pos); pos -= step }
      positions.unshift(pos)
      return positions
    }

    function addTimingPatterns(matrix, reserved, size) {
      for (let i = 8; i < size - 8; i++) {
        matrix[6][i] = i % 2 === 0
        matrix[i][6] = i % 2 === 0
        reserved[6][i] = true
        reserved[i][6] = true
      }
    }

    function reserveFormatArea(reserved, size) {
      for (let i = 0; i < 9; i++) { reserved[8][i] = true; reserved[i][8] = true }
      for (let i = 0; i < 8; i++) { reserved[8][size - 1 - i] = true; reserved[size - 1 - i][8] = true }
    }

    function encodeData(data, version) {
      const totalCodewords = [0,26,44,70,100,134,172,196,242,292,346][version]
      const ecCodewords = [0,10,16,26,18,24,16,18,22,22,26][version]
      const dataCodewords = totalCodewords - ecCodewords

      let bits = '0100'
      bits += data.length.toString(2).padStart(version < 10 ? 8 : 16, '0')
      for (let i = 0; i < data.length; i++) bits += data.charCodeAt(i).toString(2).padStart(8, '0')

      const maxBits = dataCodewords * 8
      bits += '0000'.slice(0, Math.min(4, maxBits - bits.length))
      while (bits.length % 8 !== 0) bits += '0'
      while (bits.length < maxBits) { bits += '11101100'; if (bits.length < maxBits) bits += '00010001' }

      const codewords = []
      for (let i = 0; i < bits.length; i += 8) codewords.push(parseInt(bits.substr(i, 8), 2))
      return codewords
    }

    function addErrorCorrection(dataCodewords, version) {
      const ecCounts = [0,10,16,26,18,24,16,18,22,22,26]
      const ecCount = ecCounts[version]
      const ecCodewords = generateEC(dataCodewords, ecCount)
      return [...dataCodewords, ...ecCodewords]
    }

    function generateEC(data, ecCount) {
      const gf = createGF()
      const gen = createGenerator(ecCount, gf)
      const msg = [...data, ...Array(ecCount).fill(0)]
      for (let i = 0; i < data.length; i++) {
        const coef = msg[i]
        if (coef !== 0) for (let j = 0; j < gen.length; j++) msg[i + j] ^= gf.mul(gen[j], coef)
      }
      return msg.slice(data.length)
    }

    function createGF() {
      const exp = new Array(512), log = new Array(256)
      let x = 1
      for (let i = 0; i < 255; i++) { exp[i] = x; log[x] = i; x <<= 1; if (x >= 256) x ^= 0x11d }
      for (let i = 255; i < 512; i++) exp[i] = exp[i - 255]
      return { exp, log, mul: (a, b) => a === 0 || b === 0 ? 0 : exp[log[a] + log[b]] }
    }

    function createGenerator(degree, gf) {
      let poly = [1]
      for (let i = 0; i < degree; i++) {
        const newPoly = new Array(poly.length + 1).fill(0)
        for (let j = 0; j < poly.length; j++) { newPoly[j] ^= poly[j]; newPoly[j + 1] ^= gf.mul(poly[j], gf.exp[i]) }
        poly = newPoly
      }
      return poly
    }

    function placeDataBits(matrix, reserved, size, codewords) {
      const bits = codewords.flatMap(b => b.toString(2).padStart(8, '0').split('').map(Number))
      let bitIndex = 0, col = size - 1, goingUp = true
      while (col > 0) {
        if (col === 6) col--
        for (let i = 0; i < size; i++) {
          const row = goingUp ? size - 1 - i : i
          for (let c = 0; c < 2; c++) {
            const cc = col - c
            if (!reserved[row][cc]) { matrix[row][cc] = bitIndex < bits.length ? bits[bitIndex++] === 1 : false }
          }
        }
        col -= 2; goingUp = !goingUp
      }
    }

    function findBestMask(matrix, reserved, size) {
      let bestMask = 0, bestPenalty = Infinity
      for (let mask = 0; mask < 8; mask++) {
        const test = matrix.map(row => [...row])
        applyMask(test, reserved, size, mask)
        const penalty = calcPenalty(test, size)
        if (penalty < bestPenalty) { bestPenalty = penalty; bestMask = mask }
      }
      return bestMask
    }

    function applyMask(matrix, reserved, size, mask) {
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          if (reserved[row][col]) continue
          let invert = false
          switch (mask) {
            case 0: invert = (row + col) % 2 === 0; break
            case 1: invert = row % 2 === 0; break
            case 2: invert = col % 3 === 0; break
            case 3: invert = (row + col) % 3 === 0; break
            case 4: invert = (Math.floor(row / 2) + Math.floor(col / 3)) % 2 === 0; break
            case 5: invert = ((row * col) % 2) + ((row * col) % 3) === 0; break
            case 6: invert = (((row * col) % 2) + ((row * col) % 3)) % 2 === 0; break
            case 7: invert = (((row + col) % 2) + ((row * col) % 3)) % 2 === 0; break
          }
          if (invert) matrix[row][col] = !matrix[row][col]
        }
      }
    }

    function calcPenalty(matrix, size) {
      let penalty = 0
      for (let row = 0; row < size; row++) {
        let count = 1
        for (let col = 1; col < size; col++) {
          if (matrix[row][col] === matrix[row][col - 1]) { count++; if (count === 5) penalty += 3; else if (count > 5) penalty++ }
          else count = 1
        }
      }
      for (let col = 0; col < size; col++) {
        let count = 1
        for (let row = 1; row < size; row++) {
          if (matrix[row][col] === matrix[row - 1][col]) { count++; if (count === 5) penalty += 3; else if (count > 5) penalty++ }
          else count = 1
        }
      }
      return penalty
    }

    function addFormatInfo(matrix, size, mask) {
      const formatBits = (0 << 3) | mask
      let d = formatBits << 10
      for (let i = 0; i < 5; i++) if (d & (1 << (14 - i))) d ^= 0x537 << (4 - i)
      const formatInfo = ((formatBits << 10) | d) ^ 0x5412
      const bits = formatInfo.toString(2).padStart(15, '0').split('').map(Number)

      for (let i = 0; i < 6; i++) matrix[8][i] = bits[14 - i] === 1
      matrix[8][7] = bits[8] === 1; matrix[8][8] = bits[7] === 1; matrix[7][8] = bits[6] === 1
      for (let i = 0; i < 6; i++) matrix[5 - i][8] = bits[i] === 1

      for (let i = 0; i < 8; i++) matrix[8][size - 1 - i] = bits[14 - i] === 1
      for (let i = 0; i < 7; i++) matrix[size - 7 + i][8] = bits[i] === 1
    }

    async function updateStatus() {
      const status = await vault.auth.initAuth()
      document.getElementById('status-fingerprint').className = `status ${status.hasFingerprint ? 'active' : 'inactive'}`
      document.getElementById('status-pin').className = `status ${status.hasPIN ? 'active' : 'inactive'}`
      document.getElementById('status-password').className = `status ${status.hasPassword ? 'active' : 'inactive'}`
      document.getElementById('status-session').className = `status ${vault.session.hasMasterKey() ? 'active' : 'inactive'}`
    }

    async function getVaultInfo() {
      const vaultData = await vault.store.getPasswordVault()
      if (!vaultData) return { passwordCount: 0, lastModified: null }
      const passwordCount = Object.values(vaultData.credentials || {}).flat().length
      const lastModified = vaultData.meta?.lastAccess || vaultData.meta?.createdAt
      return { passwordCount, lastModified }
    }

    window.showEnrollFingerprint = function() {
      vault.auth.startFingerprintEnrollment()
      const masterKey = vault.session.getMasterKey()
      showModal(`
        <h3>Enroll Fingerprint</h3>
        ${masterKey ? '<p style="color:#888;margin-bottom:16px;">Adding fingerprint to existing vault.</p>' : '<p style="color:#888;margin-bottom:16px;">This will create a new vault.</p>'}
        <div class="timer" id="enroll-timer">60s remaining</div>
        <div style="margin-top:16px;">
          <button onclick="enrollFingerprint()">Scan Fingerprint</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
      startCountdown('enroll-timer', 60, () => {
        hideModal()
        log('Fingerprint enrollment expired', 'error')
      })
    }

    window.enrollFingerprint = async function() {
      log('Enrolling fingerprint...')
      const masterKey = vault.session.getMasterKey()
      const result = await vault.auth.enrollFingerprint(masterKey)
      hideModal()
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('Fingerprint enrolled', 'success')
      } else {
        log(`Enrollment failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.authFingerprint = async function() {
      log('Auth with fingerprint...')
      const result = await vault.auth.authenticateFingerprint()
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('Auth successful', 'success')
      } else {
        if (result.error.includes('Wait')) {
          const seconds = parseInt(result.error.match(/\d+/)[0])
          showLockout('fingerprint', seconds)
        }
        log(`Auth failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.showSetPIN = function() {
      vault.auth.startPINCreation()
      const masterKey = vault.session.getMasterKey()
      showModal(`
        <h3>Set PIN</h3>
        ${masterKey ? '<p style="color:#888;margin-bottom:16px;">Adding PIN to existing vault.</p>' : '<p style="color:#888;margin-bottom:16px;">This will create a new vault.</p>'}
        <input type="text" id="modal-pin" placeholder="4-6 digits" maxlength="6">
        <div class="timer" id="pin-timer">60s remaining</div>
        <div style="margin-top:16px;">
          <button onclick="setPIN()">Set PIN</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
      startCountdown('pin-timer', 60, () => {
        hideModal()
        log('PIN creation expired', 'error')
      })
    }

    window.setPIN = async function() {
      const pin = document.getElementById('modal-pin').value
      const masterKey = vault.session.getMasterKey()
      const result = await vault.auth.setPIN(pin, masterKey)
      hideModal()
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('PIN set', 'success')
        if (result.isNewVault) log('New vault created', 'success')
      } else {
        log(`Set PIN failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.authPIN = async function() {
      const pin = document.getElementById('pin-input').value
      const result = await vault.auth.authenticatePIN(pin)
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('Auth successful', 'success')
      } else {
        if (result.error.includes('Wait')) {
          const seconds = parseInt(result.error.match(/\d+/)[0])
          showLockout('PIN', seconds)
        }
        log(`Auth failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.showSetPassword = function() {
      vault.auth.startPasswordCreation()
      const masterKey = vault.session.getMasterKey()
      showModal(`
        <h3>Set Password</h3>
        ${masterKey ? '<p style="color:#888;margin-bottom:16px;">Adding password to existing vault.</p>' : '<p style="color:#888;margin-bottom:16px;">This will create a new vault.</p>'}
        <input type="password" id="modal-password" placeholder="8+ characters">
        <div class="timer" id="password-timer">60s remaining</div>
        <div style="margin-top:16px;">
          <button onclick="setPassword()">Set Password</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
      startCountdown('password-timer', 60, () => {
        hideModal()
        log('Password creation expired', 'error')
      })
    }

    window.setPassword = async function() {
      const password = document.getElementById('modal-password').value
      const masterKey = vault.session.getMasterKey()
      const result = await vault.auth.setPassword(password, masterKey)
      hideModal()
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('Password set', 'success')
        if (result.isNewVault) log('New vault created', 'success')
      } else {
        log(`Set password failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.authPassword = async function() {
      const password = document.getElementById('password-input').value
      const result = await vault.auth.authenticatePassword(password)
      if (result.success) {
        vault.session.setMasterKey(result.masterKey)
        log('Auth successful', 'success')
      } else {
        if (result.error.includes('Wait')) {
          const seconds = parseInt(result.error.match(/\d+/)[0])
          showLockout('password', seconds)
        }
        log(`Auth failed: ${result.error}`, 'error')
      }
      updateStatus()
    }

    window.showSaveCredential = function() {
      if (!vault.session.hasMasterKey()) { log('Auth required', 'error'); return }
      const domain = document.getElementById('domain-input').value || 'website.com'
      showModal(`
        <h3>Add Credential</h3>
        <input type="text" id="modal-domain" value="${domain}" placeholder="website.com">
        <input type="text" id="modal-login" placeholder="Login">
        <input type="password" id="modal-password-cred" placeholder="Password">
        <div style="margin-top:16px;">
          <button onclick="saveCredential()">Save</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
    }

    window.saveCredential = async function() {
      const masterKey = vault.session.getMasterKey()
      if (!masterKey) { log('Not authenticated', 'error'); hideModal(); return }
      const domain = document.getElementById('modal-domain').value
      const login = document.getElementById('modal-login').value
      const password = document.getElementById('modal-password-cred').value
      const result = await vault.passwords.saveCredential(domain, login, password, masterKey)
      if (result.success) {
        log(`Credential saved for ${domain}`, 'success')
        document.getElementById('domain-input').value = domain
        loadCredentials()
      } else {
        log(`Save failed: ${result.error}`, 'error')
      }
      hideModal()
    }

    window.loadCredentials = async function() {
      const masterKey = vault.session.getMasterKey()
      const domain = document.getElementById('domain-input').value
      const listEl = document.getElementById('credentials-list')
      if (!masterKey) { listEl.innerHTML = '<p style="color:#666;padding:8px 0;">Auth required</p>'; return }
      if (!domain) { listEl.innerHTML = '<p style="color:#666;padding:8px 0;">Enter domain to load</p>'; return }
      const result = await vault.passwords.getCredentials(domain, masterKey)
      if (!result.success) { listEl.innerHTML = `<p style="color:#e74c3c;padding:8px 0;">${result.error}</p>`; return }
      if (result.credentials.length === 0) { listEl.innerHTML = '<p style="color:#666;padding:8px 0;">No credentials for this domain</p>'; return }
      listEl.innerHTML = result.credentials.map(c => `
        <div class="credential-row" data-id="${c.id}">
          <div class="credential-info">
            <div class="credential-login">${c.username}</div>
            <div class="credential-pass" data-visible="false"></div>
          </div>
          <button class="eyeball" onclick="togglePassword(this, '${c.password.replace(/'/g, "\\'")}')">
            <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
          </button>
          <button class="small danger" onclick="deleteCredential('${c.id}')">X</button>
        </div>
      `).join('')
    }

    window.togglePassword = function(btn, password) {
      const passEl = btn.parentElement.querySelector('.credential-pass')
      const visible = passEl.dataset.visible === 'true'
      passEl.textContent = visible ? '' : password
      passEl.dataset.visible = !visible
    }

    window.deleteCredential = async function(id) {
      if (!confirm('Delete this credential?')) return
      const result = await vault.passwords.deleteCredential(id)
      if (result.success) { log('Credential deleted', 'success'); loadCredentials() }
      else log(`Delete failed: ${result.error}`, 'error')
    }

    window.startSecureSync = async function() {
      if (!vault.session.hasMasterKey()) { log('Auth required to sync', 'error'); return }
      const vaultInfo = await getVaultInfo()
      log('Starting Secure Sync...')
      const pairData = await pairing.initiatePairing()
      syncState = { ...pairData }
      const qrSvg = generateQRCode(pairData.qrData, 200)
      showModal(`
        <h3>Secure Sync</h3>
        <p class="sync-step active">Scan this QR on the other device</p>
        <div class="qr-wrapper"><div class="qr-container">${qrSvg}</div></div>
        <div class="vault-info">
          <div class="vault-info-row"><span class="vault-info-label">Passwords</span><span class="vault-info-value">${vaultInfo.passwordCount}</span></div>
          <div class="vault-info-row"><span class="vault-info-label">Last Modified</span><span class="vault-info-value">${vaultInfo.lastModified ? new Date(vaultInfo.lastModified).toLocaleString() : 'Never'}</span></div>
        </div>
        <div class="timer" id="sync-timer">60s remaining</div>
        <div style="margin-top:16px;">
          <button onclick="syncEnterResponse()">Other Device Ready</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
      startCountdown('sync-timer', 60, () => { hideModal(); log('Sync expired', 'error') })
    }

    window.syncEnterResponse = function() {
      showModal(`
        <h3>Secure Sync</h3>
        <p class="sync-step active">Enter response from other device</p>
        <textarea id="sync-response-data" rows="4" placeholder="Paste response data"></textarea>
        <div style="margin-top:16px;">
          <button onclick="syncProcessResponse()">Verify</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
    }

    window.syncProcessResponse = async function() {
      const responseData = document.getElementById('sync-response-data').value.trim()
      let parsed
      try { parsed = JSON.parse(responseData) } catch (e) { log('Invalid response format', 'error'); return }

      if (parsed.type === 'valid-vault-pair-response') {
        const result = await pairing.completePairing(syncState.privateKey, parsed.publicKey)
        syncState.sharedKey = result.sharedKey
        syncState.pin = result.pin

        const myVault = await vault.store.getPasswordVault()
        const myTimestamp = myVault?.meta?.lastAccess || myVault?.meta?.createdAt || 0

        if (parsed.timestamp && parsed.timestamp > myTimestamp) {
          showModal(`
            <h3>You Have the Latest Version</h3>
            <p style="color:#888;margin-bottom:16px;">The other device has a more recent vault.</p>
            <p style="color:#e74c3c;">To update this device, initiate Secure Sync from the other device instead.</p>
            <div style="margin-top:16px;"><button onclick="hideModal()">OK</button></div>
          `)
          return
        }

        showModal(`
          <h3>Verify PIN</h3>
          <p class="sync-step active">Confirm this PIN matches the other device</p>
          <div class="pin-display">${result.pin}</div>
          <p style="color:#888;text-align:center;margin-bottom:16px;">Both devices must show the same PIN</p>
          <div style="margin-top:16px;">
            <button onclick="syncConfirmAndSend()">PINs Match - Sync</button>
            <button onclick="hideModal()" class="danger">PINs Don't Match</button>
          </div>
        `)
      } else if (parsed.iv && parsed.ciphertext) {
        if (!syncState.sharedKey) { log('No active sync session', 'error'); return }
        try {
          const decrypted = await pairing.decryptTransfer(parsed, syncState.sharedKey)
          const result = await pairing.receiveTransfer(decrypted)
          if (result.success) {
            vault.session.setMasterKey(result.masterKey)
            hideModal()
            log(`Vault synced: ${result.imported.passwordCount} passwords`, 'success')
            updateStatus()
          } else log(`Sync failed: ${result.error}`, 'error')
        } catch (e) { log(`Decryption failed: ${e.message}`, 'error') }
      } else log('Unknown response format', 'error')
    }

    window.syncConfirmAndSend = async function() {
      log('Preparing vault for sync...')
      const masterKey = vault.session.getMasterKey()
      const transfer = await pairing.prepareTransfer(masterKey)
      if (!transfer.success) { log(`Sync failed: ${transfer.error}`, 'error'); hideModal(); return }
      const encrypted = await pairing.encryptTransfer(transfer.data, syncState.sharedKey)
      const payload = JSON.stringify(encrypted)
      showModal(`
        <h3>Sync Ready</h3>
        <p class="sync-step active">Send this to the other device</p>
        <textarea id="sync-payload" rows="5" readonly>${payload}</textarea>
        <p style="color:#00d4aa;text-align:center;margin-top:12px;">Syncing ${transfer.meta.passwordCount} passwords</p>
        <div style="margin-top:16px;">
          <button onclick="copyPayload()">Copy</button>
          <button onclick="hideModal()" class="secondary">Done</button>
        </div>
      `)
      log(`Vault ready to sync (${transfer.meta.passwordCount} passwords)`, 'success')
    }

    window.copyPayload = function() {
      const textarea = document.getElementById('sync-payload')
      textarea.select()
      document.execCommand('copy')
      log('Payload copied to clipboard', 'success')
    }

    window.syncScanQR = function() {
      showModal(`
        <h3>Secure Sync</h3>
        <p class="sync-step active">Paste QR data from other device</p>
        <textarea id="sync-qr-data" rows="4" placeholder="Paste QR data"></textarea>
        <div style="margin-top:16px;">
          <button onclick="syncProcessQR()">Connect</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
    }

    window.syncProcessQR = async function() {
      const qrData = document.getElementById('sync-qr-data').value.trim()
      const parsed = pairing.parseQR(qrData)
      if (!parsed.success) { log(`Invalid QR: ${parsed.error}`, 'error'); return }
      log('Processing sync request...')
      const response = await pairing.respondToPairing(parsed.publicKey)
      const myVault = await vault.store.getPasswordVault()
      const myTimestamp = myVault?.meta?.lastAccess || myVault?.meta?.createdAt || 0
      syncState = { sharedKey: response.sharedKey, pin: response.pin }
      const responseWithTimestamp = { ...JSON.parse(response.responseData), timestamp: myTimestamp }
      showModal(`
        <h3>Secure Sync</h3>
        <p class="sync-step active">Send this response to the other device</p>
        <textarea id="sync-response" rows="4" readonly>${JSON.stringify(responseWithTimestamp)}</textarea>
        <div class="pin-display">${response.pin}</div>
        <p style="color:#888;text-align:center;">Verify this PIN matches the other device</p>
        <div style="margin-top:16px;">
          <button onclick="copyResponse()">Copy Response</button>
          <button onclick="syncWaitForPayload()">Next</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
    }

    window.copyResponse = function() {
      const textarea = document.getElementById('sync-response')
      textarea.select()
      document.execCommand('copy')
      log('Response copied to clipboard', 'success')
    }

    window.syncWaitForPayload = function() {
      showModal(`
        <h3>Secure Sync</h3>
        <p class="sync-step active">Enter vault data from other device</p>
        <textarea id="sync-payload-input" rows="5" placeholder="Paste encrypted vault data"></textarea>
        <div style="margin-top:16px;">
          <button onclick="syncImport()">Import</button>
          <button onclick="hideModal()" class="secondary">Cancel</button>
        </div>
      `)
    }

    window.syncImport = async function() {
      const payloadData = document.getElementById('sync-payload-input').value.trim()
      let encrypted
      try { encrypted = JSON.parse(payloadData) } catch (e) { log('Invalid payload format', 'error'); return }
      log('Importing vault...')
      try {
        const decrypted = await pairing.decryptTransfer(encrypted, syncState.sharedKey)
        const result = await pairing.receiveTransfer(decrypted)
        if (result.success) {
          vault.session.setMasterKey(result.masterKey)
          hideModal()
          log(`Vault synced: ${result.imported.passwordCount} passwords`, 'success')
          updateStatus()
        } else log(`Import failed: ${result.error}`, 'error')
      } catch (e) { log(`Decryption failed: ${e.message}`, 'error') }
    }

    window.lockAll = function() {
      vault.session.lockAll()
      document.getElementById('credentials-list').innerHTML = ''
      log('Locked', 'success')
      updateStatus()
    }

    window.clearAll = async function() {
      if (!confirm('Clear ALL vault data? This cannot be undone.')) return
      await vault.store.clearAll()
      vault.session.lockAll()
      document.getElementById('credentials-list').innerHTML = ''
      log('All data cleared', 'success')
      updateStatus()
    }

    updateStatus()
    log('Valid Vault loaded')
  

</body>
</html>
